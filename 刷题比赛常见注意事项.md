### 1. 二元组排序
当面临二元组或多元组排序时，一定要明确当第一个值相等，第二个值按什么方式排序

### 2. 排序数组中查找
1. 注意重复元素
2. 注意特殊元素，如0

当在排序数组中查找某个元素的n倍是否存在于数组中时，需要注意特殊情况0，以及多个0

### 3. 二分查找
1. 无论是upper_bound还是lower_bound, [0, size()]中的每个下标都有可能取到
2. 注意upper_bound为取大于target的第一个元素

在一个有序数组中arr查找区间`[arr[l], arr[r]]`，求得l和r的值 ：

一种思想：
处理lower_bound或者upper_bound时，我们应该先将下标修改至有效区间，保证其不访问非法下标。

然后在处理其他逻辑，这才是最通用稳健的做法

### 4. 字符串匹配
需要明确空串是否为子串


### 5. 矩阵旋转
注意矩阵旋转后各个元素对应的位置是否符合期望

### 取模运算
正确的取模运算：
`((a+b)%n+n)%n`  
把a和b看作是任何`x+y`或者`x-y`或者`x*y`运算

而`(a+b+n)%n`是不对的，`(a+b+n)%n`可能是负数。



### 6. 链表删除的一些常见问题
- [1, 1, 2, 2, 3, 3] 删除多余元素变为[1, 2, 3]
  - 注意事项，删除最后一个3时，prev指针的next记得更新为nullptr
  - 删除时，只有当前不被删除，prev指针才移动



### 7. 使用next_permutation时一定要先排序


### 8. map的隐式插入
```cpp
map<pair<int, int>, bool> vis;

if(!vis[{1, 1}]){

}
```
- 如果(1, 1)没有访问过，那么会新插入记录，并置其为false。  
- 可以使用find()来避免上面的情况发生，auto it = vis.find({1, 1})